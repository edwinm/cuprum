"use strict";Object.defineProperty(exports,"__esModule",{value:!0});
/**
 cuprum 0.1.15
 @copyright 2020 Edwin Martin <edwin@bitstorm.org>
 @license MIT
 */
class s{constructor(){this.subscribers=new Set,this.subscribersHot=new Set,this.dispatched=!1,this.hot=!1,this.isSubject=!1}dispatch(s){if(this.isSubject)throw new Error("Can't dispatch on subject");return this.internalDispatch(s),this}subscribe(s){return this.dispatched&&s(this.val),this.subscribeNext(s)}unsubscribe(s){this.subscribers.delete(s),this.notifyHotSubscribers()}subscribeHot(s){return this.subscribersHot.add(s),{unsubscribe:()=>{this.subscribersHot.delete(s)}}}clear(){this.subscribers.clear(),this.subscribersHot.clear()}value(){return this.val}observable(){const s=this.map(s=>s);return s.isSubject=!0,s}promise(){return new Promise(s=>{const t=this.subscribe((function(e){t.unsubscribe(),s(e)}))})}map(t){const e=new s,r=s=>{e.internalDispatch(t(s))};return e.subscribeHot(s=>{s?this.subscribe(r):this.unsubscribe(r)}),e}filter(t){const e=new s,r=s=>{t(s)&&e.dispatch(s)};return e.subscribeHot(s=>{s?this.subscribe(r):this.unsubscribe(r)}),e}notifyHotSubscribers(){this.subscribers.size>0!=this.hot&&(this.hot=this.subscribers.size>0,this.subscribersHot.forEach(s=>s(this.hot)))}subscribeNext(s){return this.subscribers.add(s),this.notifyHotSubscribers(),{unsubscribe:()=>{this.subscribers.delete(s)}}}internalDispatch(s){const t=this.val;this.val=s,this.dispatched=!0,this.subscribers.forEach(e=>e(s,t))}}function t(t,e,r){const i=new s,c=s=>{i.dispatch(s)};return i.subscribeHot(s=>{s?t.addEventListener(e,c,r):t.removeEventListener(e,c,r)}),i}exports.Cuprum=s,exports.combine=function(...t){const e=new s,r=new Set;return e.subscribeHot(s=>{s?t.forEach(s=>{r.add(s.subscribe(()=>{e.dispatch(t.map(s=>s.value()))}))}):r.forEach(s=>s.unsubscribe())}),e},exports.fromCustomEvent=t,exports.fromEvent=function(s,e,r){return t(s,e,r)},exports.interval=function(t){const e=new s;let r,i=null;return e.subscribeHot(s=>{s?(r=0,i=setInterval(()=>{e.dispatch(r++)},t)):clearInterval(i)}),e},exports.merge=function(...t){const e=new s,r=new Set;return e.subscribeHot(s=>{s?t.forEach(s=>{r.add(s.subscribe(s=>{e.dispatch(s)}))}):r.forEach(s=>s.unsubscribe())}),e};
//# sourceMappingURL=bundle.common.min.js.map
