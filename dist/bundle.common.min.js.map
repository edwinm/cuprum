{"version":3,"file":"bundle.common.min.js","sources":["../src/cuprum.ts"],"sourcesContent":["export class Cuprum<T> {\n  private val: T;\n  private subscribers: Set<(value: T, oldValue?: T) => void> = new Set();\n  private subscribersHot: Set<(value: boolean) => void> = new Set();\n  private dispatched = false;\n  private hot = false;\n  private isSubject = false;\n\n  dispatch(value: T) {\n    if (this.isSubject) {\n      throw \"Can't dispatch on subject\";\n    }\n    this.internalDispatch(value);\n    return this;\n  }\n\n  subscribe(fn: (value: T, oldValue?: T) => void) {\n    if (this.dispatched) {\n      fn(this.val);\n    }\n    return this.subscribeNext(fn);\n  }\n\n  unsubscribe(fn: (value: T, oldValue?: T) => void) {\n    this.subscribers.delete(fn);\n    this.notifyHotSubscribers();\n  }\n\n  subscribeHot(fn: (value: boolean) => void) {\n    this.subscribersHot.add(fn);\n    return {\n      unsubscribe: () => {\n        this.subscribersHot.delete(fn);\n      },\n    };\n  }\n\n  clear() {\n    this.subscribers.clear();\n    this.subscribersHot.clear();\n  }\n\n  value() {\n    return this.val;\n  }\n\n  observable(): Observable<T> {\n    const observable = this.map((value) => value);\n    observable.isSubject = true;\n    return observable;\n  }\n\n  promise() {\n    return new Promise<T>((resolve) => {\n      const sub = this.subscribe(function fn(value) {\n        sub.unsubscribe();\n        resolve(value);\n      });\n    });\n  }\n\n  // TODO: async map\n\n  map<U>(fn: (val: T) => U) {\n    const event$ = new Cuprum<U>();\n    const dispatch = (value) => {\n      event$.internalDispatch(fn(value));\n    };\n    event$.subscribeHot((hot) => {\n      if (hot) {\n        this.subscribe(dispatch);\n      } else {\n        this.unsubscribe(dispatch);\n      }\n    });\n    return event$;\n  }\n\n  filter(fn: (val: T) => boolean) {\n    const event$ = new Cuprum<T>();\n    const dispatch = (value) => {\n      if (fn(value)) {\n        event$.dispatch(value);\n      }\n    };\n    event$.subscribeHot((hot) => {\n      if (hot) {\n        this.subscribe(dispatch);\n      } else {\n        this.unsubscribe(dispatch);\n      }\n    });\n    return event$;\n  }\n\n  private notifyHotSubscribers() {\n    if (this.subscribers.size > 0 != this.hot) {\n      this.hot = this.subscribers.size > 0;\n      this.subscribersHot.forEach((fn) => fn(this.hot));\n    }\n  }\n\n  private subscribeNext(fn: (value: T) => void): Subscription {\n    this.subscribers.add(fn);\n    this.notifyHotSubscribers();\n    return {\n      unsubscribe: () => {\n        this.subscribers.delete(fn);\n      },\n    };\n  }\n\n  private internalDispatch(value: T) {\n    const oldValue = this.val;\n    this.val = value;\n    this.dispatched = true;\n    this.subscribers.forEach((fn) => fn(value, oldValue));\n  }\n}\n\nexport function tap(fn: (val: any) => any) {\n  fn(this.val);\n  return this;\n}\n\nexport function fromEvent(element, eventType) {\n  const obs$ = new Cuprum<Event>();\n  const dispatch = (evt: Event) => {\n    obs$.dispatch(evt);\n  };\n  obs$.subscribeHot((hot) => {\n    if (hot) {\n      element.addEventListener(eventType, dispatch, false);\n    } else {\n      element.removeEventListener(eventType, dispatch, false);\n    }\n  });\n  return obs$;\n}\n\nexport function combine<T>(obs1$: Cuprum<T>): Cuprum<[T]>;\nexport function combine<T, U>(\n  obs1$: Cuprum<T>,\n  obs2$: Cuprum<U>\n): Cuprum<[T, U]>;\nexport function combine<T, U, V>(\n  obs1$: Cuprum<T>,\n  obs2$: Cuprum<U>,\n  obs3$: Cuprum<V>\n): Cuprum<[T, U, V]>;\nexport function combine<T, U, V, W>(\n  obs1$: Cuprum<T>,\n  obs2$: Cuprum<U>,\n  obs3$: Cuprum<V>,\n  obs4$: Cuprum<W>\n): Cuprum<[T, U, V, W]>;\nexport function combine<T, U, V, W, X>(\n  obs1$: Cuprum<T>,\n  obs2$: Cuprum<U>,\n  obs3$: Cuprum<V>,\n  obs4$: Cuprum<W>,\n  obs5$: Cuprum<X>\n): Cuprum<[T, U, V, W, X]>;\nexport function combine<T, U, V, W, X, Y>(\n  obs1$: Cuprum<T>,\n  obs2$: Cuprum<U>,\n  obs3$: Cuprum<V>,\n  obs4$: Cuprum<W>,\n  obs5$: Cuprum<X>,\n  obs6$: Cuprum<Y>\n): Cuprum<[T, U, V, W, X, Y]>;\nexport function combine<T, U, V, W, X, Y, Z>(\n  obs1$: Cuprum<T>,\n  obs2$: Cuprum<U>,\n  obs3$: Cuprum<V>,\n  obs4$: Cuprum<W>,\n  obs5$: Cuprum<X>,\n  obs6$: Cuprum<Y>,\n  obs7$: Cuprum<Z>\n): Cuprum<[T, U, V, W, X, Y, Z]>;\n\nexport function combine(...cuprumList: Cuprum<unknown>[]) {\n  const obs$ = new Cuprum();\n  const subs = new Set<Subscription>();\n\n  obs$.subscribeHot((hot) => {\n    if (hot) {\n      cuprumList.forEach((obs) => {\n        subs.add(\n          obs.subscribe(() => {\n            obs$.dispatch(cuprumList.map((obs1) => obs1.value()));\n          })\n        );\n      });\n    } else {\n      subs.forEach((sub) => sub.unsubscribe());\n    }\n  });\n\n  return obs$;\n}\n\nexport function merge<T>(obs1$: Cuprum<T>): Cuprum<T>;\nexport function merge<T>(obs1$: Cuprum<T>, obs2$: Cuprum<T>): Cuprum<T>;\nexport function merge<T>(\n  obs1$: Cuprum<T>,\n  obs2$: Cuprum<T>,\n  obs3$: Cuprum<T>\n): Cuprum<T>;\nexport function merge<T>(\n  obs1$: Cuprum<T>,\n  obs2$: Cuprum<T>,\n  obs3$: Cuprum<T>,\n  obs4$: Cuprum<T>\n): Cuprum<T>;\nexport function merge<T>(\n  obs1$: Cuprum<T>,\n  obs2$: Cuprum<T>,\n  obs3$: Cuprum<T>,\n  obs4$: Cuprum<T>,\n  obs5$: Cuprum<T>\n): Cuprum<T>;\nexport function merge<T>(\n  obs1$: Cuprum<T>,\n  obs2$: Cuprum<T>,\n  obs3$: Cuprum<T>,\n  obs4$: Cuprum<T>,\n  obs5$: Cuprum<T>,\n  obs6$: Cuprum<T>\n): Cuprum<T>;\nexport function merge<T>(\n  obs1$: Cuprum<T>,\n  obs2$: Cuprum<T>,\n  obs3$: Cuprum<T>,\n  obs4$: Cuprum<T>,\n  obs5$: Cuprum<T>,\n  obs6$: Cuprum<T>,\n  obs7$: Cuprum<T>\n): Cuprum<T>;\nexport function merge(...cuprumList: Cuprum<unknown>[]) {\n  const obs$ = new Cuprum();\n  const subs = new Set<Subscription>();\n\n  obs$.subscribeHot((hot) => {\n    if (hot) {\n      cuprumList.forEach((obs) => {\n        subs.add(\n          obs.subscribe((value) => {\n            obs$.dispatch(value);\n          })\n        );\n      });\n    } else {\n      subs.forEach((sub) => sub.unsubscribe());\n    }\n  });\n\n  return obs$;\n}\n\nexport function interval(msec) {\n  const obs$ = new Cuprum();\n  let timer = <NodeJS.Timeout>null;\n  let counter;\n\n  obs$.subscribeHot((hot) => {\n    if (hot) {\n      counter = 0;\n      timer = setInterval((event) => {\n        obs$.dispatch(counter++);\n      }, msec);\n    } else {\n      clearInterval(timer);\n    }\n  });\n\n  return obs$;\n}\n\nexport type Observable<T> = Omit<Cuprum<T>, \"dispatch\">;\n\nexport interface Subscription {\n  unsubscribe: () => void;\n}\n"],"names":["Cuprum","[object Object]","this","Set","value","isSubject","internalDispatch","fn","dispatched","val","subscribeNext","subscribers","delete","notifyHotSubscribers","subscribersHot","add","unsubscribe","clear","observable","map","Promise","resolve","sub","subscribe","event$","dispatch","subscribeHot","hot","size","forEach","oldValue","cuprumList","obs$","subs","obs","obs1","element","eventType","evt","addEventListener","removeEventListener","msec","counter","timer","setInterval","event","clearInterval"],"mappings":"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"}