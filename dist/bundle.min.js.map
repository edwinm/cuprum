{"version":3,"file":"bundle.min.js","sources":["../src/cuprum.ts"],"sourcesContent":["/**\n cuprum __buildVersion__\n @copyright 2023 Edwin Martin <edwin@bitstorm.org>\n @license MIT\n */\nexport class Cuprum<T> {\n  private val!: T;\n  private subscribers: Set<(value: T, oldValue?: T) => void> = new Set();\n  private subscribersHot: Set<(value: boolean) => void> = new Set();\n  private dispatched = false;\n  private hot = false;\n  private isSubject = false;\n\n  dispatch(value: T): Cuprum<T> {\n    if (this.isSubject) {\n      throw new Error(\"Can't dispatch on subject\");\n    }\n    this.internalDispatch(value);\n    return this;\n  }\n\n  subscribe(fn: (value: T, oldValue?: T) => void): Subscription {\n    if (this.dispatched) {\n      fn(this.val);\n    }\n    return this.subscribeNext(fn);\n  }\n\n  unsubscribe(fn: (value: T, oldValue?: T) => void): void {\n    this.subscribers.delete(fn);\n    this.notifyHotSubscribers();\n  }\n\n  subscribeHot(fn: (value: boolean) => void): Subscription {\n    this.subscribersHot.add(fn);\n    return {\n      unsubscribe: (): void => {\n        this.subscribersHot.delete(fn);\n      },\n    };\n  }\n\n  clear(): void {\n    this.subscribers.clear();\n    this.subscribersHot.clear();\n  }\n\n  value(): T {\n    return this.val;\n  }\n\n  observable(): Observable<T> {\n    const observable = this.map((value) => value);\n    observable.isSubject = true;\n    return observable;\n  }\n\n  promise(): Promise<T> {\n    return new Promise<T>((resolve) => {\n      const sub = this.subscribe(function fn(value) {\n        sub.unsubscribe();\n        resolve(value);\n      });\n    });\n  }\n\n  // TODO: async map\n\n  map<U>(fn: (val: T) => U): Cuprum<U> {\n    const event$ = new Cuprum<U>();\n    const dispatch = (value: T) => {\n      event$.internalDispatch(fn(value));\n    };\n    event$.subscribeHot((hot) => {\n      if (hot) {\n        this.subscribe(dispatch);\n      } else {\n        this.unsubscribe(dispatch);\n      }\n    });\n    return event$;\n  }\n\n  filter(fn: (val: T) => boolean): Cuprum<T> {\n    const event$ = new Cuprum<T>();\n    const dispatch = (value: T) => {\n      if (fn(value)) {\n        event$.dispatch(value);\n      }\n    };\n    event$.subscribeHot((hot) => {\n      if (hot) {\n        this.subscribe(dispatch);\n      } else {\n        this.unsubscribe(dispatch);\n      }\n    });\n    return event$;\n  }\n\n  private notifyHotSubscribers() {\n    if (this.subscribers.size > 0 != this.hot) {\n      this.hot = this.subscribers.size > 0;\n      this.subscribersHot.forEach((fn) => fn(this.hot));\n    }\n  }\n\n  private subscribeNext(fn: (value: T) => void): Subscription {\n    this.subscribers.add(fn);\n    this.notifyHotSubscribers();\n    return {\n      unsubscribe: (): void => {\n        this.subscribers.delete(fn);\n      },\n    };\n  }\n\n  private internalDispatch(value: T) {\n    const oldValue = this.val;\n    this.val = value;\n    this.dispatched = true;\n    this.subscribers.forEach((fn) => fn(value, oldValue));\n  }\n}\n\nexport function fromEvent<K extends keyof WindowEventMap>(\n  element: Window,\n  eventType: K,\n  options?: boolean | AddEventListenerOptions\n): Cuprum<WindowEventMap[K]>;\n\nexport function fromEvent<K extends keyof DocumentEventMap>(\n  element: Document,\n  eventType: K,\n  options?: boolean | AddEventListenerOptions\n): Cuprum<DocumentEventMap[K]>;\n\nexport function fromEvent<K extends keyof HTMLElementEventMap>(\n  element: HTMLElement,\n  eventType: K,\n  options?: boolean | AddEventListenerOptions\n): Cuprum<HTMLElementEventMap[K]>;\n\nexport function fromEvent(\n  element: HTMLElement | Document | Window,\n  eventType: string,\n  options?: boolean | AddEventListenerOptions\n) {\n  return fromCustomEvent(element, eventType, options);\n}\n\nexport function fromCustomEvent(\n  element: HTMLElement | Document | Window,\n  eventType: string,\n  options?: boolean | AddEventListenerOptions\n) {\n  const obs$ = new Cuprum();\n  const dispatch = (evt: unknown) => {\n    obs$.dispatch(evt);\n  };\n  obs$.subscribeHot((hot) => {\n    if (hot) {\n      element.addEventListener(eventType, dispatch, options);\n    } else {\n      element.removeEventListener(eventType, dispatch, options);\n    }\n  });\n  return obs$;\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nexport function combine<T>(obs1$: Observable<T>): Observable<[T]>;\nexport function combine<T, U>(\n  obs1$: Observable<T>,\n  obs2$: Observable<U>\n): Observable<[T, U]>;\nexport function combine<T, U, V>(\n  obs1$: Observable<T>,\n  obs2$: Observable<U>,\n  obs3$: Observable<V>\n): Observable<[T, U, V]>;\nexport function combine<T, U, V, W>(\n  obs1$: Observable<T>,\n  obs2$: Observable<U>,\n  obs3$: Observable<V>,\n  obs4$: Observable<W>\n): Observable<[T, U, V, W]>;\nexport function combine<T, U, V, W, X>(\n  obs1$: Observable<T>,\n  obs2$: Observable<U>,\n  obs3$: Observable<V>,\n  obs4$: Observable<W>,\n  obs5$: Observable<X>\n): Observable<[T, U, V, W, X]>;\nexport function combine<T, U, V, W, X, Y>(\n  obs1$: Observable<T>,\n  obs2$: Observable<U>,\n  obs3$: Observable<V>,\n  obs4$: Observable<W>,\n  obs5$: Observable<X>,\n  obs6$: Observable<Y>\n): Observable<[T, U, V, W, X, Y]>;\nexport function combine<T, U, V, W, X, Y, Z>(\n  obs1$: Observable<T>,\n  obs2$: Observable<U>,\n  obs3$: Observable<V>,\n  obs4$: Observable<W>,\n  obs5$: Observable<X>,\n  obs6$: Observable<Y>,\n  obs7$: Observable<Z>\n): Observable<[T, U, V, W, X, Y, Z]>;\n\nexport function combine(\n  ...cuprumList: Observable<unknown>[]\n): Observable<unknown> {\n  const obs$ = new Cuprum();\n  const subs = new Set<Subscription>();\n\n  obs$.subscribeHot((hot) => {\n    if (hot) {\n      cuprumList.forEach((obs) => {\n        subs.add(\n          obs.subscribe(() => {\n            obs$.dispatch(cuprumList.map((obs1) => obs1.value()));\n          })\n        );\n      });\n    } else {\n      subs.forEach((sub) => sub.unsubscribe());\n    }\n  });\n\n  return <Observable<unknown>>obs$;\n}\n\nexport function merge<T>(...cuprumList: Observable<T>[]): Observable<T> {\n  const obs$ = new Cuprum();\n  const subs = new Set<Subscription>();\n\n  obs$.subscribeHot((hot) => {\n    if (hot) {\n      cuprumList.forEach((obs) => {\n        subs.add(\n          obs.subscribe((value) => {\n            obs$.dispatch(value);\n          })\n        );\n      });\n    } else {\n      subs.forEach((sub) => sub.unsubscribe());\n    }\n  });\n\n  return <Observable<T>>obs$;\n}\n\nexport function interval(msec: number): Cuprum<unknown> {\n  const obs$ = new Cuprum();\n  let timer = <NodeJS.Timeout>(null as unknown);\n  let counter: number;\n\n  obs$.subscribeHot((hot) => {\n    if (hot) {\n      counter = 0;\n      timer = setInterval(() => {\n        obs$.dispatch(counter++);\n      }, msec);\n    } else {\n      clearInterval(timer);\n    }\n  });\n\n  return obs$;\n}\n\nexport type Observable<T> = Omit<Cuprum<T>, \"dispatch\">;\n\nexport interface Subscription {\n  unsubscribe: () => void;\n}\n"],"names":["Cuprum","constructor","this","subscribers","Set","subscribersHot","dispatched","hot","isSubject","dispatch","value","Error","internalDispatch","subscribe","fn","val","subscribeNext","unsubscribe","delete","notifyHotSubscribers","subscribeHot","add","clear","observable","map","promise","Promise","resolve","sub","event$","filter","size","forEach","oldValue","fromEvent","element","eventType","options","fromCustomEvent","obs$","evt","addEventListener","removeEventListener","combine","cuprumList","subs","obs","obs1","merge","interval","msec","counter","timer","setInterval","clearInterval"],"mappings":"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"}