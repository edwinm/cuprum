class s{constructor(){this.subscribers=new Set,this.subscribersHot=new Set,this.dispatched=!1,this.hot=!1}dispatch(s){this.val=s,this.dispatched=!0,this.subscribers.forEach(t=>t(s))}subscribeNext(s){return this.subscribers.add(s),this.notifyHotSubscribers(),{unsubscribe:()=>{this.subscribers.delete(s)}}}subscribe(s){return this.dispatched&&s(this.val),this.subscribeNext(s)}unsubscribe(s){this.subscribers.delete(s),this.notifyHotSubscribers()}notifyHotSubscribers(){this.subscribers.size>0!=this.hot&&(this.hot=this.subscribers.size>0,this.subscribersHot.forEach(s=>s(this.hot)))}subscribeHot(s){return this.subscribersHot.add(s),{unsubscribe:()=>{this.subscribersHot.delete(s)}}}clear(){this.subscribers.clear(),this.subscribersHot.clear()}value(){return this.val}promise(){return new Promise(s=>{const t=this;this.subscribe((function i(e){t.unsubscribe(i),s(e)}))})}map(t){const i=new s,e=s=>{i.dispatch(t(s))};return i.subscribeHot(s=>{s?this.subscribe(e):this.unsubscribe(e)}),i}filter(t){const i=new s,e=s=>{t(s)&&i.dispatch(s)};return i.subscribeHot(s=>{s?this.subscribe(e):this.unsubscribe(e)}),i}}function t(s){return s(this.val),this}function i(t,i){const e=new s,r=s=>{e.dispatch(s)};return e.subscribeHot(s=>{s?t.addEventListener(i,r,!1):t.removeEventListener(i,r,!1)}),e}export{s as Cuprum,i as fromEvent,t as tap};
//# sourceMappingURL=bundle.min.js.map
